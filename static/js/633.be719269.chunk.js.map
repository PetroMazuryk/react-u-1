{"version":3,"file":"static/js/633.be719269.chunk.js","mappings":"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","sources":["webpack://react-u-1/./src/components/CodeBlock/CodeBlock.module.css?c236","components/CodeBlock/CodeBlock.jsx","webpack://react-u-1/./src/components/InlineCode/InlineCode.module.css?959a","components/InlineCode/InlineCode.jsx","webpack://react-u-1/./src/components/LessonBlock/LessonBlock.module.css?2270","components/LessonBlock/LessonBlock.jsx","data/tasksJS.js","webpack://react-u-1/./src/pages/TasksPage/TasksPage.module.css?84c8","pages/TasksPage/TasksPage.jsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"pre\":\"CodeBlock_pre__GSvC6\"};","import {useEffect, useRef} from \"react\";\nimport Prism from \"prismjs\";\n\nimport \"prismjs/components/prism-javascript\";\nimport \"prismjs/themes/prism-tomorrow.css\";\n\nimport styles from \"./CodeBlock.module.css\";\n\nfunction CodeBlock({code, language = \"javascript\"}) {\n  const codeRef = useRef(null);\n\n  useEffect(() => {\n    if (codeRef.current) {\n      Prism.highlightElement(codeRef.current);\n    }\n  }, [code]);\n\n  return (\n    <pre className={styles.pre}>\n      <code ref={codeRef} className={`language-${language}`}>\n        {code}\n      </code>\n    </pre>\n  );\n}\n\nexport default CodeBlock;\n","// extracted by mini-css-extract-plugin\nexport default {\"code\":\"InlineCode_code__rIV9z\"};","import styles from \"./InlineCode.module.css\";\n\nfunction InlineCode({children}) {\n  return <span className={styles.code}>{children}</span>;\n}\n\nexport default InlineCode;\n","// extracted by mini-css-extract-plugin\nexport default {\"block\":\"LessonBlock_block__ayiIj\",\"title\":\"LessonBlock_title__dOukI\",\"number\":\"LessonBlock_number__nEsTr\",\"link\":\"LessonBlock_link__Ah4VO\",\"requirements\":\"LessonBlock_requirements__5ULLH\",\"summary\":\"LessonBlock_summary__KPrB-\",\"description\":\"LessonBlock_description__1mLLm\"};","import CodeBlock from \"../CodeBlock/CodeBlock\";\nimport InlineCode from \"../InlineCode/InlineCode\";\n\nimport styles from \"./LessonBlock.module.css\";\n\nconst LessonBlock = ({task}) => {\n  const {\n    id,\n    title,\n    link,\n    requirements,\n    description,\n    inlineCode,\n    starterCode,\n    solution,\n    language = \"javascript\",\n  } = task;\n\n  return (\n    <section className={styles.block}>\n      <h3 className={styles.title}>\n        <span className={styles.number}>{id}</span> {title}\n        {link && (\n          <a\n            href={link}\n            target=\"_blank\"\n            rel=\"noreferrer\"\n            className={styles.link}\n          >\n            ▶ Відео YouTube\n          </a>\n        )}\n      </h3>\n\n      {requirements && (\n        <ul className={styles.requirements}>\n          {requirements.map((req, index) => (\n            <li key={`${req}-${index}`}>{req}</li>\n          ))}\n        </ul>\n      )}\n\n      {inlineCode && (\n        <p className={styles.inline}>\n          <InlineCode>{inlineCode}</InlineCode>\n        </p>\n      )}\n\n      {starterCode && <CodeBlock code={starterCode} language={language} />}\n\n      {solution && (\n        <details className={styles.solution}>\n          <summary className={styles.summary}>Показати рішення</summary>\n          <CodeBlock code={solution} language={language} />\n          {description && <p className={styles.description}>{description}</p>}\n        </details>\n      )}\n    </section>\n  );\n};\n\nexport default LessonBlock;\n","export const tasksJS = [\n  {\n    id: 1,\n    link: \"https://www.youtube.com/watch?v=OZPOO79Y4jk&t=4503s\",\n    title: \"Реалізуй функцію 'resolve' [ 55:20 ]\",\n    requirements: [\n      \"На вхід функції передається масив промісів, а на виході вона повертає новий проміс.\",\n      \"Новий проміс працює за такими правилами:\",\n      \"1) Якщо в масиві є хоча б один успішний проміс — повернути результат цього промісу.\",\n      \"2) Якщо всі проміси завершуються з reject — повернути reject з масивом усіх помилок.\",\n    ],\n    inlineCode: `Вихід: Кейс 1 — Promise => 5 ; Кейс 2 — Promise => Error(errors) ;`,\n    starterCode: `function resolve(promises) {}\n[(Promise.resolve(1), Promise.resolve(2)];\n[(Promise.reject(3), Promise.resolve(4)];\n[(Promise.reject(5), Promise.reject(6)];`,\n\n    solution: `function resolve(promises) {\n  return new Promise((resolve, reject) => {\n    const errors = [];\n    let rejectedCount = 0;\n\n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then(result => {\n          resolve(result); // перший успішний — готово\n        })\n        .catch(error => {\n          errors[index] = error;\n          rejectedCount++;\n\n          if (rejectedCount === promises.length) {\n            reject(errors); // всі впали\n          }\n        });\n    });\n  });\n}\nresolve([Promise.resolve(1), Promise.resolve(2)]).then(console.log); // 1\nresolve([Promise.reject(3), Promise.resolve(4)]).then(console.log); // 4\nresolve([Promise.reject(5), Promise.reject(6)]).catch(console.log); // [5, 6]`,\n    description: `Відразу викликає resolve при першому успішному промісі, навіть якщо інші\n     проміси можуть виконатися пізніше. Це стандартна поведінка промісів, але треба пам’ятати.\n    Масив errors зберігає помилки по індексу, що добре для порядку, але не обов’язково потрібно,\n    можна просто робити errors.push(error).`,\n  },\n  {\n    id: 2,\n    link: \"https://www.youtube.com/watch?v=OZPOO79Y4jk&t=4503s\",\n    title: \"Реалізуй функцію 'resolve': Варіант 2 \",\n    requirements: [\n      \"Сучасний і компактний варіант цієї функції через async/await.\",\n      \"Він робить те ж саме, але код читати легше:\",\n    ],\n\n    solution: `async function resolve(promises) {\n  if (promises.length === 0) {\n    return Promise.reject([]); // порожній масив\n  }\n  const results = await Promise.allSettled(promises);\n\n  // шукаємо перший успішний проміс\n  const fulfilled = results.find(r => r.status === 'fulfilled');\n  if (fulfilled) {\n    return fulfilled.value;\n    }\n    \n  // якщо всі проміси відхилилися\n  const errors = results\n    .filter(r => r.status === 'rejected')\n    .map(r => r.reason);\n\n  // return Promise.reject(errors);\n  throw errors;\n  // throw results.filter(r => r.status === 'rejected').map(r => r.reason);\n}\nresolve([Promise.resolve(1), Promise.resolve(2)]).then(console.log); // 1\nresolve([Promise.reject(3), Promise.resolve(4)]).then(console.log); // 4\nresolve([Promise.reject(5), Promise.reject(6)]).catch(console.log); // [5, 6]`,\n  },\n  {\n    id: 3,\n    link: \"https://www.youtube.com/watch?v=OZPOO79Y4jk&t=4503s\",\n    title: \"Дано масив цілих натуральних чисел [ 1:07:00 ]\",\n    requirements: [\n      \"Потрібно згрупувати між собою числа ,\",\n      \"які можна отримати шляхом перестановки їхніх цифр.\",\n      \"Тобто всі числа в числі одиникові просто переставлені по різному.\",\n    ],\n    starterCode: `function digitPermutation(arr) {\n  // your code here\n}\nconsole.clear();\nconsole.log('start test');\nconsole.log(\n  digitPermutation([1230, 199, 2301, 1230, 110001, 3021, 101010, 991, 9]);\n  // Очікувано: [[9],[199,991],[1230,2301,1230,3021],[110001,101010]]\n);\nconsole.log(digitPermutation([11], [22])); // [[11],[22]]\nconsole.log(digitPermutation([11, 11, 11])); // [[11,11,11]]\nconsole.log(digitPermutation([111111111112], [122222222222])); //[[1222222222],[111111111112]]\nconsole.log('end test');`,\n    solution: `function digitPermutation(arr) {\n  const map = new Map();\n\n  arr.forEach(num => {\n    // Перетворюємо число на рядок, сортуємо цифри та отримуємо ключ\n    const key = String(num).split('').sort().join('');\n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    map.get(key).push(num);\n  });\n\n  // Збираємо результат: лише групи з більше ніж одного числа\n  const result = [];\n  for (const group of map.values()) {\n    if (group.length > 1) {\n      result.push(group);\n    }\n  }\n\n  return result;\n}\n\n// Приклади\nconsole.clear();\nconsole.log('start test');\nconsole.log(digitPermutation([1230, 199, 2301, 1230, 110001, 3021, 101010, 991, 9]));\n// Очікувано: [[1230, 2301, 1230], [199, 991], [110001, 101010], [9]]\nconsole.log(digitPermutation([11, 22])); // [[11],[22]]\nconsole.log(digitPermutation([11, 11, 11]));// [[11, 11, 11]]\nconsole.log(digitPermutation([111111111112, 1222222222])); // [[111111111112], [1222222222]]\nconsole.log('end test');\n`,\n    description: `Для кожного числа створюється ключ із відсортованих цифр.\nMap зберігає всі числа з однаковим ключем в масиві.\nВсі масиви (групи) повертаються як результат.\n✅ Таким чином, навіть одиничні числа (що не мають перестановок) потрапляють\nу групу по одному.`,\n  },\n  {\n    id: 4,\n    link: \"\",\n    title: \"Дано масив цілих натуральних чисел \",\n    requirements: [\n      \"Версія функції, де повертаються тільки групи з більше ніж одного числа –\",\n      \"тобто справжні перестановки цифр.\",\n    ],\n    starterCode: `console.log(digitPermutation([1230, 199, 2301, 1230, 110001, 3021, 101010, 991, 9]));\n// Очікувано: [[1230, 2301, 1230], [199, 991], [110001, 101010]]\nconsole.log(digitPermutation([11, 22])); // []\nconsole.log(digitPermutation([11, 11, 11])); // [[11, 11, 11]]\nconsole.log(digitPermutation([111111111112, 1222222222])); // []`,\n    solution: `function digitPermutation(arr) {\n  const map = new Map();\n\n  arr.forEach(num => {\n    const key = String(num).split('').sort().join('');\n    if (!map.has(key)) { // Якщо такого ключа ще немає — створити його\n      map.set(key, []); // створює новий запис у Map: ключ: key  - значення: порожній масив\n    }\n    map.get(key).push(num); // Кладемо число num у відповідну групу\n  });\n\n  // Повертаємо тільки групи, де більше одного числа\n  const result = Array.from(map.values()).filter(group => group.length > 1);\n  return result;\n}\n\n// Тести\nconsole.clear();\nconsole.log('start test');\nconsole.log(digitPermutation([1230, 199, 2301, 1230, 110001, 3021, 101010, 991, 9]));\n// Очікувано: [[1230, 2301, 1230], [199, 991], [110001, 101010]]\nconsole.log(digitPermutation([11, 22])); // []\nconsole.log(digitPermutation([11, 11, 11])); // [[11, 11, 11]]\nconsole.log(digitPermutation([111111111112, 1222222222])); // []\nconsole.log('end test');\n\n`,\n    description: `Тепер одиничні числа та унікальні перестановки не включаються,\n     а залишаються лише справжні групи. map — це Map, структура даних для зберігання пар\nключ → значення`,\n  },\n  {\n    id: 5,\n    link: \"\",\n    title: \"Дано масив цілих натуральних чисел \",\n    requirements: [\n      \"Варіант з об’єктом {}\",\n      \"Тобто всі числа в числі одиникові просто переставлені по різному.\",\n    ],\n    starterCode: `function digitPermutation(arr) {\n     // your code here  }\n    console.log(digitPermutation([1230, 199, 2301, 1230, 110001, 3021, 101010, 991, 9]);\n    // Очікувано: [[9],[199,991],[1230,2301,1230,3021],[110001,101010]]);\n    console.log(digitPermutation([11], [22])); // [[11],[22]]\n    console.log(digitPermutation([11, 11, 11])); // [[11,11,11]]\n    console.log(digitPermutation([111111111112], [122222222222])); //[[1222222222],[111111111112]]`,\n    solution: `function digitPermutation(arr) {\n  const obj = {};\n\n  for (const num of arr) {\n    const key = String(num).split('').sort().join('');\n\n    if (!obj[key]) {\n      obj[key] = [];\n    }\n\n    obj[key].push(num);\n  }\n\n  return Object.values(obj);\n}\n\nconsole.log(digitPermutation([1230, 199, 2301, 1230, 110001, 3021, 101010, 991, 9]));\n// Очікувано: [[1230, 2301, 1230], [199, 991], [110001, 101010], [9]]\nconsole.log(digitPermutation([11, 22])); // [[11],[22]]\nconsole.log(digitPermutation([11, 11, 11]));// [[11, 11, 11]]\nconsole.log(digitPermutation([111111111112, 1222222222])); // [[111111111112], [1222222222]]\n`,\n    description: `Важлива відмінність Map vs Object\n  Map: Будь-які ключі- has()\t- Кращий для великих даних  ///              \n\t Object:  Ключі → рядки - if (!obj[key]) - Простий і швидкий. Чому я бачу:\n   (4) [Array(3), Array(2), Array(2), Array(1)] замість [[1230, 2301, 1230], [199, 991], [110001, 101010], [9]]\n   Це одне й те саме. DevTools просто згортає вкладені масиви, щоб не захаращувати консоль.\n   Примусово вивести «як у прикладі».  Варіант 1 — через JSON.stringify:\n   console.log(JSON.stringify(digitPermutation([\n  1230, 199, 2301, 1230, 110001, 3021, 101010, 991, 9\n])));`,\n  },\n  {\n    id: 6,\n    link: \"https://www.youtube.com/watch?v=OZPOO79Y4jk&t=4503s\",\n    title: \"useCollback , useMemo  [ 32:24 ]\",\n    requirements: [\n      \"Зробити так, щоб при рендері батька не ререндирився Child,\",\n      \"якщо не помінявся velue або onClick\",\n    ],\n    starterCode: `interface CompProps{ }\n\nfunction Child(onClick, value) { }\n\nexport function Comp(props: CompProps) {\n    const onClick = () => { }\n    const value = {\n        num:'123'\n    }\n    return (\n        <div>\n    <Child value={value} onClick={onClick}/>\n        </div>\n    )\n}`,\n    solution: `import React, { useCallback, useMemo } from 'react';\n\ninterface CompProps {\n  title: string;\n}\n\n\ninterface ChildProps {\n  onClick: () => void;\n  value: { num: string };\n}\n\nconst Child: React.FC<ChildProps> = React.memo(({ onClick, value }) => {\n  console.log('Child render');\n  return (\n    <div>\n      <button onClick={onClick}>{value.num}</button>\n    </div>\n  );\n});\n\nexport function Comp({ title }: CompProps) {\n const [count, setCount] = React.useState(0);\n \n  const onClick = useCallback(() => {\n    console.log('Clicked in Child');\n  }, []);\n\n  const value = useMemo(() => ({ num: '123' }), []);\n  console.log('Parent render');\n\n  return (\n    <>\n        <h1>{title}</h1>\n      <button onClick={() => setCount(c => c + 1)}>\n        Parent + {count}\n      </button>\n\n      <Child value={value} onClick={onClick} />\n    </>\n  );\n}\n\nexport default Comp;\n`,\n    description: ` useCallback фіксує функцію між ререндерингами. \n    [] → функція створюється один раз. Посилання на onClick не змінюєтьсяю\nChild не рендериться повторно без потреби.\nuseMemo фіксує об’єкт value, щоб він не створювався заново.\nReact.memo запам’ятовує результат рендеру компонента і НЕ перерендерює його, якщо props\n не змінилися (порівняння за ===). Тобто Child перерендериться лише тоді, коли:\n зміниться onClick або зміниться value.\nmemo - використовуєжться для компонентіа, відбувається поверхневе порівняння пропсів,\nі компонент буде бачити , що посилання на value не помінялося, onClick не помінявся.\n а useMemo використовується для даних. Висновок:\nmemo – оптимізація для компонентів (поверхневе порівняння пропсів).\nuseMemo – оптимізація для даних.  useCallback – оптимізація для функцій.`,\n  },\n  {\n    id: 7,\n    link: \"https://www.youtube.com/watch?v=hkrmyIecHR0&ab_channel=UlbiTV\",\n    title: \"Реалізація debounce [ 24:32 ]\",\n    requirements: [\n      \"Написати функцію debounce(callback, delay), яка повертає нову функцію.\",\n      \"Якщо викликають новий раз раніше, ніж пройшов delay, попередній таймер скасовується.\",\n      \"Після затримки викликається callback з останніми аргументами.\",\n      \"5 раз визивається fetching() з різними аргументами а ми вивели лише fetching 5\",\n    ],\n    starterCode: `const fetchUrl = url => {\n  console.log(\\`fetching \\${url}...\\`);\n};\nfunction debounce(callback, delay) {\n}\nconst fetching = debounce(fetchUrl, 300);\n\nfetching(1);\nfetching(2);\nfetching(3);\nfetching(4);\nfetching(5);`,\n    solution: `const fetchUrl = url => {\n  console.log(\\`fetching \\${url}...\\`); // повертає: fetching 5...\n};\n\nfunction debounce(callback, delay) {\n  let timer = null;\n  return (...args) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      callback(...args);\n    }, delay);\n  };\n}\n\nconst fetching = debounce(fetchUrl, 300);\n\nfetching(1);\nfetching(2);\nfetching(3);\nfetching(4);\nfetching(5);`,\n    description: ` debounce - для того, щоб приривати попередні дії і відкладено виконувати останні.\n    Кожен виклик скасовує попередній таймер. Після останнього виклику fetching(5) таймер\n     відраховує 300 мс, і тільки тоді викликається fetchUrl(5). debounce дуже популярний у\n     фронтенд-розробці, особливо при роботі з подіями, які можуть спрацьовувати дуже часто.\n      Його головна мета — зменшити кількість викликів функції, що зберігає ресурси та покращує\n       продуктивність. У даному випадку обмежити виклики функції, щоб уникнути перевантаження\n       системи або сервера.`,\n  },\n  {\n    id: 8,\n    link: \"https://www.youtube.com/watch?v=hkrmyIecHR0&ab_channel=UlbiTV\",\n    title: \"Реалізація debounce [ 26:25 ]\",\n    requirements: [\"Щоб крім пятірки, ще появлявся Bob \"],\n    starterCode: `const fetchUrl = url => {\n  console.log(\\`fetching \\${url}...\\`, this.firstName);\n};\nconst user = {\n    firstName: 'Bob',\n};\n\nfunction debounce(callback, delay) {\n  let timer = null;\n  return (...args) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      callback(...args);\n    }, delay);\n  };\n}\n\nconst fetching = debounce(fetchUrl, 300);\n\nfetching(1);\nfetching(2);\nfetching(3);\nfetching(4);\nfetching(5);`,\n    solution: `const fetchUrl2 = function (url) {\n  console.log(\\`fetching \\${url}...\\`, this.firstName); //  fetching 5... Bob\n};\n\nconst user = {\n  firstName: 'Bob',\n};\n\nfunction debounce(callback, delay) {\n  let timer = null;\n  return (...args) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      callback(...args);\n    }, delay);\n  };\n}\nconst fetching2 = debounce(fetchUrl2.bind(user), 300);\n\nfetching2(1);\nfetching2(2);\nfetching2(3);\nfetching2(4);`,\n    description: `Щоб ще виводився Bob (поміняв стрілку на function + bind(user)). \n    Стрілочна функція не має власного this. Вона лексично захоплює this з зовнішнього скоупу\n(у браузері це window, у strict — undefined).\nЯкщо додати ще один bind, тобто const fetching2 = debounce(fetchUrl2.bind(user).bind({}), 300).\nТо все одно виведе fetching 5... Bob, тому що другий bind не змінює this,\nоскільки this вже зафіксований першим bind. ( Запамятовує перший контекст.)`,\n  },\n  {\n    id: 9,\n    link: \"https://www.youtube.com/watch?v=hkrmyIecHR0&ab_channel=UlbiTV\",\n    title: \"Деревовидна структура [ 28:38 ]\",\n    requirements: [\n      \"Пройтися по всій структурі та зібрати values в масив.\",\n      \"Використати ітеративний підхід (через стек)\",\n    ],\n    starterCode: `const tree = {\n  value: 1,\n  children: [\n    {\n      value: 2,\n      children: [{ value: 3 }],\n    },\n    {\n      value: 4,\n      children: [{ value: 5 }, { value: 6 }],\n    },\n  ],\n};\nfunction getTreeValues(tree) {\n  // your code here\n}\nconsole.log(getTreeValues(tree)); // [1,4,6,5,2,3]`,\n    solution: `const tree = {\n  value: 1,\n  children: [\n    {\n      value: 2,\n      children: [{ value: 3 }],\n    },\n    {\n      value: 4,\n      children: [{ value: 5 }, { value: 6 }],\n    },\n  ],\n};\nfunction getTreeValues(tree) {\n  const stack = [tree];\n\n  const result = [];\n\n  while (stack.length > 0) {\n    const node = stack.pop();\n    if (node.value !== undefined) {\n      result.push(node.value);\n    }\n    if (node.children?.length) {\n      stack.push(...node.children);\n    }\n    // if (node.children) {\n    //   // додаємо у зворотному порядку, щоб порядок DFS зберігся\n    //   // DFS (Depth-First Search) — це пошук у глибину, один із базових алгоритмів обходу графів та дерев.\n    //  // Графи — це структури даних, які описують зв’язки між об’єктами.\n    //   for (let i = node.children.length - 1; i >= 0; i--) {\n    //     stack.push(node.children[i]);\n    //   }\n    // }\n  }\n  return result;\n}\nconsole.log(getTreeValues(tree)); // [1,4,6,5,2,3]`,\n    description: `Якщо велика вкладеність, то краще через стек, щоб уникнути помилки\n     переповнення.`,\n  },\n  {\n    id: 10,\n    link: \"\",\n    title: \"Деревовидна структура: Варіант 2\",\n    requirements: [\n      \"Пройтися по всій структурі та зібрати values в масив.\",\n      \"Використати рекурсивний підхід\",\n    ],\n    starterCode: `const tree = {\n  value: 1,\n  children: [\n    {\n      value: 2,\n      children: [{ value: 3 }],\n    },\n    {\n      value: 4,\n      children: [{ value: 5 }, { value: 6 }],\n    },\n  ],\n};\nfunction getTreeValues(tree) {\n  // your code here\n}\nconsole.log(getTreeValues(tree)); // [1,4,6,5,2,3]`,\n    solution: `const tree = {\n  value: 1,\n  children: [\n    {\n      value: 2,\n      children: [{ value: 3 }],\n    },\n    {\n      value: 4,\n      children: [{ value: 5 }, { value: 6 }],\n    },\n  ],\n};\n\nfunction getTreeValuesRecursive(node) {\n   const values = [node.value];  // починаємо з поточного вузла\n  if (node.children) {\n    for (const child of node.children) {\n      values.push(...getTreeValuesRecursive(child)); // рекурсивно додаємо значення дітей\n    }\n  }\n  return values;\n}\nconst values = getTreeValuesRecursive(tree);\nconsole.log(values); // [1,2,3,4,5,6]\n\n// 2  знайти суму всіх значень value\nconst sum = values.reduce((acc, val) => acc + val, 0);\nconsole.log(sum); // 21\n\n// 3  знайти суму всіх значень value за допомогою ф-ції getTreeSum\nfunction getTreeSum(node) {\n  let sum = node.value || 0;\n  if (node.children) {\n    for (const child of node.children) {\n      sum += getTreeSum(child);\n    }\n  }\n  return sum;\n}\nconsole.log(getTreeSum(tree)); // 21\n`,\n    description: `Створюємо масив values із поточним вузлом\nЯкщо є children, то для кожного викликаємо функцію рекурсивно\nЧерез ... додаємо всі значення дочірніх вузлів в масив\nПовертаємо масив. Рекурсія в JS обмежена ~10000 викликів.\n Для невеликої глибини проблем не буде. Якщо потрібно швидко отримати\n масив значень або обробити вузли — рекурсія економить час. Якщо дерево дуже глибоке (1000+ рівнів) →\n рекурсія може викликати RangeError: Maximum call stack size exceeded`,\n  },\n  {\n    id: 11,\n    link: \"https://www.youtube.com/watch?v=hkrmyIecHR0&ab_channel=UlbiTV\",\n    title: \"Рефокторинг коду: React. [32:30]\",\n    requirements: [\"Зробити ревю та виправити помилки в коді нижче.\"],\n    starterCode: `\n    import React, {useState} from \"react\";\n\nconst initList = () => {\n  return Array.from({ length: 200 }, (_el, index) => ({\n    value: Math.random(),\n    label: \"row \" + (index + 1),\n  }));\n};\nexport function NewsPage() {\n  const [list] = useState(initList);\n\n  const handleUpdate = () => {\n    list[0].value = Math.random();\n  };\n\n  return (\n    <>\n      <h1>List News Page</h1>\n      <Button onClick={handleUpdate}>Update  \" row 1 \"</Button>\n      {list.map(({label, value}) => (\n        <Row label={value} value={value} />\n      ))}\n    </>\n  );\n}\n\nfunction Button(props) {\n  const {children, onClick} = props;\n  return <button onClick={onClick}>{children}</button>;\n}\n\nfunction Row(props) {\n  const { label, value } = props\n  return (\n    <div style={{marginTop: 8}}>\n      <span style={{ marginRight: 20 }}>{label}</span>\n      <span>{value}</span>\n    </div>\n  );\n}\n\nexport default NewsPage;\n`,\n    solution: `import  {useState, memo} from \"react\";\n    \n    const initList = () =>\n      Array.from({length: 10}, (_el, index) => ({\n        value: Math.random(),\n        label: \"row \" + (index + 1),\n      }));\n    \n    export function NewsPage() {\n      const [list, setList] = useState(initList);\n    \n      const handleUpdate = () => {\n        setList((prev) =>\n          prev.map((item, index) =>\n            index === 0 ? {...item, value: Math.random()} : item,\n          ),\n        );\n      };\n    \n      return (\n        <>\n          <h1>List News Page</h1>\n          <Button onClick={handleUpdate}>Update \"row 1\"</Button>\n    \n          {list.map(({label, value}) => (\n            <Row key={label} label={label} value={value} />\n          ))}\n        </>\n      );\n    }\n    \n    function Button(props) {\n      const {children, onClick} = props;\n      return <button onClick={onClick}>{children}</button>;\n    }\n    \n    function Row(props) {\n      const {label, value} = props;\n      return (\n        <div style={{marginTop: 8}}>\n          <span style={{marginRight: 20}}>{label}</span>\n          <span>{value}</span>\n        </div>\n      );\n    }\n\n    // const Row = memo(function(props) {\n    //   const {label, value} = props;\n    //   return (\n    //     <div style={{marginTop: 8}}>\n    //       <span style={{marginRight: 20}}>{label}</span>\n    //       <span>{value}</span>\n    //     </div>\n    //   );\n    // })\n    \n    export default NewsPage;`,\n    description: `Якщо ми натиснемо кнопку \"Update row 1\", \n    то крім першої строки будуть перерендуватися всі інші.\n    Щоб цьому запобігти, потрібно: обернути компонент Row в memo.\n   `,\n  },\n  {\n    id: 12,\n    link: \"https://www.youtube.com/watch?v=hkrmyIecHR0&ab_channel=UlbiTV\",\n    title: \"Відмінність any від unknown [38:21]\",\n    requirements: [\n      \"any і unknown обидва означають “невідомий тип”, але поводяться принципово по-різному \",\n    ],\n    starterCode: `const user = await fetch().json();  // any\nfunction someFn(str: string) {\n}\nsomeFn(user) // якщо ми в цю ф-цію передамо масив юзерів то TypeScript не видасть помилку\n// Якщо user насправді масив або об’єкт — помилка з’явиться лише в runtime\n\nconst user = await fetch().json();  // unknown\nfunction someFn(str: string) {\n}\nsomeFn(user) // ПОМИЛКА TS: Argument of type 'unknown' is not assignable to parameter of type 'string'.`,\n    solution: `\nany — вимикає TypeScript. ✅ TypeScript дозволяє все. ❌ Помилки з’являться тільки під час виконання.\nз unknown TypeScript забороняє будь-які дії, поки ти не перевіриш тип. unknown = “я не знаю тип, доведи мені”.\n\nif (typeof value === \"string\") {\n  value.toUpperCase(); // ✅\n}\nПрисвоєння типів\nlet a: any = 5;\nlet b: number = a; // ✅\n\nlet u: unknown = 5;\nlet c: number = u; // ❌\n\nПравильно з unknown:\nif (typeof u === \"number\") {\n  c = u; // ✅\n}\n\nРеальний приклад (API / JSON)\nfunction parse(data: unknown) {\n  if (typeof data === \"object\" && data !== null && \"name\" in data) {\n    return (data as { name: string }).name;\n  }\n}\nНе використовуй any:\nу Redux\nу React props\nу відповідях API\n\n✅ Використовуй unknown:\nпри роботі з JSON.parse\nз API\nу catch (error: unknown)\nколи тип реально невідомий\n\nРеальний приклад використання\nconst response: unknown = await fetch().json();\n\nconst name = parse(response);\n\nif (name) {\n  console.log(name.toUpperCase());\n}\n\nКоротко запамʼятати:\nunknown → перевіряй перед використанням\ntypeof data === \"object\" → відсіює примітиви\ndata !== null → обовʼязково! , бо typeof null === \"object\"\n\"name\" in data → перевірка поля\nas → пояснює тип TS, не перевіряє його\n`,\n    description: ``,\n  },\n  {\n    id: 13,\n    link: \"https://www.youtube.com/watch?v=nqwJDi-z738\",\n    title: \"На синхронність JavaScript  [ 41:00 ]\",\n    requirements: [\"В якій послідовності виведуться console.log\"],\n    starterCode: `console.log('0');\n\nsetTimeout(function timeuot() {\n  console.log('1');\n}, 100);\n\nlet p = new Promise(function (resolve, reject) {\n  console.log('2');\n  resolve();\n});\n\np.then(function () {\n  console.log('3');\n});\n\nsetTimeout(function timeout() {\n  console.log('5');\n}, 0);\nconsole.log('6');`,\n    solution: `\n     // 0 2 6 3 5 1 ) Створення нового  промісу це синхронний код\n    `,\n    description: ``,\n  },\n  {\n    id: 14,\n    link: \"https://www.youtube.com/watch?v=nqwJDi-z738\",\n    title: \"Розкласти масив на рядок з діапазонами [42:57]\",\n    requirements: [\n      \"Вхід масив чисел. Вихід рядок з діапазоном.\",\n      \" Необхідно перетворити отриманний на вхід масив в рядок\",\n      \" згортаючи сусідні по числовому ряду числа в діапвзон\",\n    ],\n    starterCode: `range([1, 4, 5, 2, 3, 9, 8, 11, 0]);\nrange([1, 4, 3, 2]);\n\nfunction range(arr) {\n  // your code here\n  }`,\n    solution: `\nfunction range(arr) {\n  const sortArr = [...arr].sort((a, b) => a - b);\n  if (!sortArr.length) {\n    return '';\n  }\n\n  const result = [String(sortArr[0])];\n  let isInterval = false;\n  for (let i = 1; i <= sortArr.length; i++) {\n    const prev = sortArr[i - 1];\n    const current = sortArr[i];\n\n    if (current - prev === 1) {\n      isInterval = true;\n      continue;\n    }\n    if (isInterval) {\n      result[result.length - 1] +=  \\`-\\${prev}\\`;\n      isInterval = false;\n    }\n    if (current !== undefined) {\n      result.push(String(current));\n    }\n  }\n  return result.join();\n}\n console.log(range([1, 4, 5, 2, 3, 9, 8, 11, 0])); // 0-5,8-9,11\n console.log(range([1, 4, 3, 2])); // 1-4`,\n    description: ``,\n  },\n  {\n    id: 15,\n    link: \"https://www.youtube.com/watch?v=nqwJDi-z738\",\n    title: \"Розкласти масив на рядок з діапазонами [42:57]\",\n    requirements: [\"Варіант 2\"],\n    starterCode: `range([1, 4, 5, 2, 3, 9, 8, 11, 0]);\nrange([1, 4, 3, 2]);\n\nfunction range(arr) {\n  // your code here\n  }`,\n    solution: `function range(arr) {\n  if (!arr.length) return '';\n\n  const sorted = [...arr].sort((a, b) => a - b);\n  const result = [];\n  let start = sorted[0];\n  for (let i = 1; i <= sorted.length; i++) {\n    // якщо кінець послідовності\n    if (sorted[i] !== sorted[i - 1] + 1) {\n      const end = sorted[i - 1];\n     result.push(start === end ? String(start) : start + '-' + end);\n      start = sorted[i];\n    }\n  }\n  // додати останній діапазон якщо for (let i = 1; i < sorted.length; i++)\n  // const end = sorted[sorted.length - 1];\n  // result.push(start === end ? String(start) : start + '-' + end);\n  return result.join(', ');\n}\n\nconsole.log(range([1, 4, 5, 2, 3, 9, 8, 11, 0])); // 0-5, 8-9, 11\nconsole.log(range([1, 4, 3, 2])); // 1-4\nconsole.log(range([7, 10, 11, 12, 20])); // 7, 10-12, 20`,\n    description: ``,\n  },\n  {\n    id: 16,\n    link: \"https://www.youtube.com/watch?v=DgyHiUmi6SU&ab_channel=WebDev%D1%81%D0%BD%D\",\n    title: \"Написати код який генерує список з N простих чисел\",\n    requirements: [\"Варіант з for\"],\n    starterCode: ``,\n    solution: `function generatePrimesOne(count) {\n  const primes = [];\n  let primeCandidate = 2;\n  while (primes.length !== count) {\n    let candidateIsPrime = true;\n    for (let i = 2; i <= Math.sqrt(primeCandidate); i++) {\n      if (primeCandidate % i === 0) {\n        candidateIsPrime = false;\n        break;\n      }\n    }\n\n    if (candidateIsPrime) primes.push(primeCandidate);\n\n    primeCandidate += 1;\n  }\n  return primes;\n}\n console.log(generatePrimesOne(10));  // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`,\n    description: ``,\n  },\n  {\n    id: 17,\n    link: \"https://www.youtube.com/watch?v=DgyHiUmi6SU&ab_channel=WebDev%D1%81%D0%BD%D\",\n    title:\n      \"Написати функцію generatePrimes(count), яка генерує масив з перших count простих чисел.\",\n    requirements: [\n      \"Варіант з every\",\n      \"count — ціле невід’ємне число, яке визначає, скільки простих чисел потрібно згенерувати.\",\n      \"Масив, що містить рівно count простих чисел у зростаючому порядку, починаючи з числа 2\",\n    ],\n    starterCode: ``,\n    solution: `function generatePrimes(count) {\n  const primes = [];\n  let candidate = 2;\n\n  while (primes.length < count) {\n    const isPrime = primes.every(\n      p => candidate % p !== 0\n    );\n\n    if (isPrime) primes.push(candidate);\n    candidate++;\n  }\n\n  return primes;\n}\n\nconsole.log(generatePrimes(10)); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`,\n    description: ``,\n  },\n  {\n    id: 18,\n    link: \"https://www.youtube.com/watch?v=DgyHiUmi6SU&ab_channel=WebDev%D1%81%D0%BD%D\",\n    title: \"Вивести прості числа\",\n    requirements: [\n      \"Написати функцію getPrimeNumbers(n), яка повертає масив усіх простих чисел від 2 до n включно.\",\n      \"\",\n    ],\n    starterCode: `j * j <= i еквівалентно j <= √i, але без обчислення\n квадратного кореня (Math.sqrt(i)), що швидше.`,\n    solution: `function getPrimeNumbers(n) {\n  const prime = [];\n\n  for (let i = 2; i <= n; i++) {\n    let isPrime = true;\n\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n\n    if (isPrime) {\n      prime.push(i);\n    }\n  }\n    \n  return prime;\n}\nconsole.log(getPrimeNumbers(20)); [2, 3, 5, 7, 11, 13, 17, 19]\n`,\n    description: ``,\n  },\n  {\n    id: 19,\n    link: \"https://www.youtube.com/watch?v=YA6yZ_KUIYA&ab_channel=wise.js\",\n    title: \"Знайти суму елементів масиву\",\n    requirements: [\"\"],\n    starterCode: `const array = [1, 2, 2, 4, 5, 6, 6];`,\n    solution: `const array = [1, 2, 2, 4, 5, 6, 6];\nlet sum = 0;\nfor (let i = 0; i < array.length; i++) {\n  sum += array[i];\n}\nconsole.log(sum); //26`,\n    description: ``,\n  },\n  {\n    id: 20,\n    link: \"https://www.youtube.com/watch?v=YA6yZ_KUIYA&ab_channel=wise.js\",\n    title: \"Знайти суму елементів масиву. Варіант з reduce \",\n    requirements: [\"\"],\n    starterCode: `const array = [1, 2, 2, 4, 5, 6, 6];`,\n    solution: `let sum = array.reduce((acc, next) => acc + next, 0);//коли по дефолту не поставити 0, то у випадку [] буде помилка\nconsole.log(sum); //26`,\n    description: ``,\n  },\n  {\n    id: 21,\n    link: \"\",\n    title: \"Максимальний або мінімальний елемент масиву \",\n    requirements: [\"\"],\n    starterCode: ``,\n    solution: `const array = [10, 2, 2, 4, 5, 6, 6];\nlet max = array[0];\nfor (let i = 0; i < array.length; i++) {\n  if (array[i] > max) {\n    max = array[i];\n  }\n}\nconsole.log(max); //10`,\n    description: ``,\n  },\n  {\n    id: 22,\n    link: \"\",\n    title: \"Максимальний або мінімальний елемент масиву \",\n    requirements: [\"Варіант з тернарним оператором \"],\n    starterCode: ``,\n    solution: `const array = [10, 2, 2, 4, 5, 6, 6];\nlet max = array[0];\nfor (let i = 0; i < array.length; i++) {\n  max = array[i] > max ? array[i] : max;\n}\nconsole.log(max); //10`,\n    description: ``,\n  },\n  {\n    id: 23,\n    link: \"\",\n    title: \" Варіант з  Math\",\n    requirements: [\" \"],\n    starterCode: ``,\n    solution: `const array = [10, 2, 2, 4, 5, 6, 6];\nlet max = array[0];\nfor (let i = 0; i < array.length; i++) {\n  max = Math.max(array[i], max);\n}\nconsole.log(max); //10`,\n    description: ``,\n  },\n  {\n    id: 24,\n    link: \"\",\n    title: \" \",\n    requirements: [\"Створення \"],\n    starterCode: ``,\n    solution: ``,\n    description: ``,\n  },\n];\n","// extracted by mini-css-extract-plugin\nexport default {\"title\":\"TasksPage_title__-UcN8\"};","import LessonBlock from \"../../components/LessonBlock/LessonBlock\";\nimport {tasksJS} from \"../../data/tasksJS\";\n\nimport styles from \"./TasksPage.module.css\";\n\nconst TasksPage = () => {\n  return (\n    <main style={{padding: \"4px\"}}>\n      <h2 className={styles.title}>Задачі JS</h2>\n\n      {tasksJS.map((task) => (\n        <LessonBlock key={task.id} task={task} />\n      ))}\n    </main>\n  );\n};\n\nexport default TasksPage;\n"],"names":["code","language","codeRef","useRef","useEffect","current","Prism","className","styles","ref","children","task","id","title","link","requirements","description","inlineCode","starterCode","solution","href","target","rel","map","req","index","CodeBlock","tasksJS","style","padding","LessonBlock"],"sourceRoot":""}